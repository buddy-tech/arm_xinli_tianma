#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <semaphore.h>
#include "pgos/MsOS.h"
#include "common.h"
#include "comStruct.h"
#include "pubpwr.h"
#include "comUart.h"
#include "client.h"
#include "common.h"
#include "clipg.h"
#include "box.h"
#include "pubPwrTask.h"
#include "pwrSerial.h"

static void setPwrCheckPause(bool bPause);
void setNtcCheckPause(bool bPause);

void printPowerInfo(sByPtnPwrInfo* pPwrInfo)
{
	printf("VDD:   %d, IVDD:   %d.\n", pPwrInfo->VDD, pPwrInfo->iVDD);
	printf("VDDIO: %d, IVDDIO: %d.\n", pPwrInfo->VDDIO, pPwrInfo->iVDDIO);
	printf("ELVDD: %d, IELVDD: %d.\n", pPwrInfo->ELVDD, pPwrInfo->iELVDD);
	printf("ELVSS: %d, IELVSS: %d.\n", pPwrInfo->ELVSS, pPwrInfo->iELVSS);
	printf("VSP:   %d, IVSP:   %d.\n", pPwrInfo->VSP, pPwrInfo->iVSP);
	printf("VSN:   %d, IVSN:   %d.\n", pPwrInfo->VSN, pPwrInfo->iVSN);
	
	printf("VBL:   %u, iVBL:   %d, \np_open_short: %d, \nn_open_short1: %d, n_open_short2: %d, "
			"n_open_short3: %d， n_open_short4: %d, n_open_short5: %d, n_open_short6: %d, "
			"status: %02x.\n", 
			pPwrInfo->VBL, pPwrInfo->iVBL,
			pPwrInfo->vbl_led_p_open_short,  pPwrInfo->vbl_led_n_open_short[0],
			pPwrInfo->vbl_led_n_open_short[1], pPwrInfo->vbl_led_n_open_short[2],
			pPwrInfo->vbl_led_n_open_short[3], pPwrInfo->vbl_led_n_open_short[4],
			pPwrInfo->vbl_led_n_open_short[5], pPwrInfo->vbl_reserved[0]);
}

static int power_check_item(short fixValue, short actualValue, unsigned short percent)
{
	int ret = E_PWR_CHECK_OK;
	do
	{
		short range = fixValue*percent/100;
		if (abs(range) < MIN_POWER_ADJUST)
		{
			if (range < 0)
				range = -MIN_POWER_ADJUST;
			else
				range = MIN_POWER_ADJUST;
		}

		short delta = fixValue - actualValue;

		if (fixValue == 0)
		{
			if (abs(actualValue) < POWER_MIN_0_VALUE)
				break;

			ret = E_PWR_CHECK_ERR_OV;
			break;
		}
		else if (fixValue > 0) //Positive value
		{
			if (actualValue < 0)
			{
				ret = E_PWR_CHECK_ERR_UV;
				break;
			}

			if (abs(delta) > abs(range))
			{
				if (delta > 0)
					ret = E_PWR_CHECK_ERR_UV;
				else
					ret = E_PWR_CHECK_ERR_OV;
			}
		}
		else	//Negative value
		{
			if (actualValue >= 0)
			{
				ret = E_PWR_CHECK_ERR_UV;
				break;
			}

			if (abs(delta) > abs(range))
			{
				if (delta > 0)
					ret = E_PWR_CHECK_ERR_OV;
				else
					ret = E_PWR_CHECK_ERR_UV;
			}
		}
	}while (0);

	return ret;
}

static int check_cc_vbl_open_short(unsigned char status)
{
	int ret = E_PWR_CHECK_OK;
	if (status)
		ret = status - 1 + E_PWR_CHECK_ERR_VBL_OPEN;

	return ret;
}

static int power_check_vbl(const s1103PwrCfgDb* pFixPwr, const sByPtnPwrInfo* pActualPwr)
{
	// background brighten protected: 0: disable; 1: enable;
	if (pFixPwr->LEDUVP == 0 || pFixPwr->LEDChannel == 0 || pFixPwr->LEDNumber == 0)
		return E_PWR_CHECK_OK;

	int ret = E_PWR_CHECK_OK;
	ret = check_cc_vbl_open_short(pActualPwr->vbl_led_p_open_short);
	if (ret)
	{
		printf("power_check_vbl error: checn P failed! status = %d.\n", ret);
		return ret;
	}

	int i = 0;
	for (; i < pFixPwr->LEDNumber; i ++)
	{
		ret = check_cc_vbl_open_short(pActualPwr->vbl_led_n_open_short[i]);
		if (ret)
		{
			printf("power_check_vbl error: checn N failed! index = %d, status = %d.\n", i, ret);
			return ret;
		}
	}

	short iVblFix = pFixPwr->LEDNumber * pFixPwr->LEDCurrent;
	ret = power_check_item(iVblFix, pActualPwr->iVBL, 10);
	if (ret)
		ret = (ret - E_PWR_CHECK_ERR_OV) + E_PWR_CHECK_ERR_OC;

	if (ret)
		ret += ret + E_PWR_CHECK_ERR_VBL_OV;

	return ret;
}

static int checkPowerEquitable(const s1103PwrCfgDb* pFixPwr, const sByPtnPwrInfo* pActualPwr)
{
	/* VDDIO */
	int ret = power_check_item(pFixPwr->VDDIO, pActualPwr->VDDIO, POWER_CHECK_PERCENT);
	if (ret)
		return ret + E_PWR_CHECK_ERR_VDD_OV;

	/* VGH */
	ret = power_check_item(pFixPwr->ELVDD, pActualPwr->ELVDD, POWER_CHECK_PERCENT);
	if (ret)
		return ret + E_PWR_CHECK_ERR_VGH_OV;

	/* VSP */
	ret = power_check_item(pFixPwr->VSP, pActualPwr->VSP, POWER_CHECK_PERCENT);
	if (ret)
		return ret + E_PWR_CHECK_ERR_VSP_OV;

	/* VGH */
	ret = power_check_item(pFixPwr->ELVSS, pActualPwr->ELVSS, POWER_CHECK_PERCENT);
	if (ret)
		return ret + E_PWR_CHECK_ERR_VGL_OV;
	
	/* VSN */
	ret = power_check_item(pFixPwr->VSN, pActualPwr->VSN, POWER_CHECK_PERCENT);
	if (ret)
		return ret + E_PWR_CHECK_ERR_VSN_OV;

	return ret;
}

#include "pwrSerial.h"

static pwrTaskInfo_t* pSgPwrTaskInfo = NULL;

typedef struct pwrErrorInfo
{
	int id;
	char error[128];
}pwrErrorInfo_t;

static pwrErrorInfo_t sgPwrErrorInfo[] =
{
		{E_PWR_CHECK_ERR_VDD_OV, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								  0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56 ,
								  0x44 ,0x44 ,0xe8 ,0xbf ,0x87 ,0xe5 ,0x8e ,0x8b ,
								  0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4 ,
								  0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0xef ,
								  0xbc ,0x81 ,0x00}}, //"电源错误：VDD过压，设备关电！"
		{E_PWR_CHECK_ERR_VDD_UV, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
				  	  	  	  	  0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56 ,
				  	  	  	  	  0x44 ,0x44 ,0xe6 ,0xac ,0xa0 ,0xe5 ,0x8e ,0x8b ,
				  	  	  	  	  0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4 ,
				  	  	  	  	  0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0xef ,
				  	  	  	  	  0xbc ,0x81 ,0x00}}, //"电源错误：VDD欠压，设备关电！"
		{E_PWR_CHECK_ERR_VDD_OC, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								  0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56 ,
								  0x44 ,0x44 ,0xe8 ,0xbf ,0x87 ,0xe6 ,0xb5 ,0x81 ,
								  0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4 ,
								  0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21 ,0x00}}, //"电源错误：VDD过流，设备关电!"
		{E_PWR_CHECK_ERR_VDD_UC, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								  0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56 ,
								  0x44 ,0x44 ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5 ,0x81 ,
								  0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4 ,
								  0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21 ,0x00}}, //"电源错误：VDD欠流，设备关电!"
		{E_PWR_CHECK_ERR_VINT_OV, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x49 ,0x4e ,0x54 ,0xe8 ,0xbf ,0x87 ,0xe5 ,
								   0x8e ,0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,
								   0xe5 ,0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,
								   0xb5 ,0x21 ,0x00}}, //"电源错误： VINT过压，设备关电!"
		{E_PWR_CHECK_ERR_VINT_UV, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x49 ,0x4e ,0x54 ,0xe6 ,0xac ,0xa0 ,0xe5 ,
								   0x8e ,0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,
								   0xe5 ,0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,
								   0xb5 ,0x21 ,0x00}}, //"电源错误： VINT欠压，设备关电!"
		{E_PWR_CHECK_ERR_VINT_OC, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x49 ,0x4e ,0x54 ,0xe8 ,0xbf ,0x87 ,0xe6 ,
								   0xb5 ,0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,
								   0xe5 ,0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,
								   0xb5 ,0x21 ,}}, //"电源错误： VINT过流，设备关电!"
		{E_PWR_CHECK_ERR_VINT_UC, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56 ,
								   0x49 ,0x4e ,0x54 ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5 ,
								   0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VINT欠流，设备关电!"
		{E_PWR_CHECK_ERR_VSP_OV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x53 ,0x50 ,0xe8 ,0xbf ,0x87 ,0xe5 ,0x8e ,
								   0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VSP过压，设备关电!"
		{E_PWR_CHECK_ERR_VSP_UV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x53 ,0x50 ,0xe6 ,0xac ,0xa0 ,0xe5 ,0x8e ,
								   0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VSP欠压，设备关电!"
		{E_PWR_CHECK_ERR_VSP_OC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x53 ,0x50 ,0xe8 ,0xbf ,0x87 ,0xe6 ,0xb5 ,
								   0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VSP过流，设备关电!"
		{E_PWR_CHECK_ERR_VSP_UC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x53 ,0x50 ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5 ,
								   0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VSP欠流，设备关电!"
		{E_PWR_CHECK_ERR_VSN_OV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x53 ,0x4e ,0xe8 ,0xbf ,0x87 ,0xe5 ,0x8e ,
								   0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VSN过压，设备关电!"
		{E_PWR_CHECK_ERR_VSN_UV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x53 ,0x4e ,0xe6 ,0xac ,0xa0 ,0xe5 ,0x8e ,
								   0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VSN欠压，设备关电!"
		{E_PWR_CHECK_ERR_VSN_OC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94 ,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20 ,
								   0x56 ,0x53 ,0x4e ,0xe8 ,0xbf ,0x87 ,0xe6 ,0xb5 ,
								   0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,
								   0x21 ,0x00}}, //"电源错误： VSN过流，设备关电!"
		{E_PWR_CHECK_ERR_VSN_UC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
				 	 	 	 	   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20,
				 	 	 	 	   0x56 ,0x53 ,0x4e ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5,
				 	 	 	 	   0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5,
				 	 	 	 	   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
				 	 	 	 	   0x21 ,0x00}}, //"电源错误： VSN欠流，设备关电!"
		{E_PWR_CHECK_ERR_VGH_OV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
								   0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20,
								   0x56 ,0x47 ,0x48 ,0xe8 ,0xbf ,0x87 ,0xe5 ,0x8e,
								   0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5,
								   0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
								   0x21 ,0x00}}, //"电源错误： VGH过压，设备关电!"
		{E_PWR_CHECK_ERR_VGH_UV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x20,
									 0x56 ,0x47 ,0x48 ,0xe6 ,0xac ,0xa0 ,0xe5 ,0x8e,
									 0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}},//"电源错误： VGH欠压，设备关电!"
		{E_PWR_CHECK_ERR_VGH_OC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x47 ,0x48 ,0xe8 ,0xbf ,0x87 ,0xe6 ,0xb5 ,0x81,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VGH过流，设备关电!"
		{E_PWR_CHECK_ERR_VGH_UC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x47 ,0x48 ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5 ,0x81,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VGH欠流，设备关电!"
		{E_PWR_CHECK_ERR_VGL_OV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x47 ,0x4c ,0xe8 ,0xbf ,0x87 ,0xe5 ,0x8e ,0x8b,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VGL过压，设备关电!"
		{E_PWR_CHECK_ERR_VGL_UV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x47 ,0x4c ,0xe6 ,0xac ,0xa0 ,0xe5 ,0x8e ,0x8b,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VGL欠压，设备关电!"
		{E_PWR_CHECK_ERR_VGL_OC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x47 ,0x4c ,0xe8 ,0xbf ,0x87 ,0xe6 ,0xb5 ,0x81,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VGL过流，设备关电!"
		{E_PWR_CHECK_ERR_VGL_UC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x47 ,0x4c ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5 ,0x81,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VGL欠流，设备关电!"
		{E_PWR_CHECK_ERR_VCOM_OV, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x43 ,0x4f ,0x4d ,0xe8 ,0xbf ,0x87 ,0xe5 ,0x8e,
									 0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： VCOM过压，设备关电!"
		{E_PWR_CHECK_ERR_VCOM_UV, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x43 ,0x4f ,0x4d ,0xe6 ,0xac ,0xa0 ,0xe5 ,0x8e,
									 0x8b ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,}}, //"电源错误： VCOM欠压，设备关电!"
		{E_PWR_CHECK_ERR_VCOM_OC, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x43 ,0x4f ,0x4d ,0xe8 ,0xbf ,0x87 ,0xe6 ,0xb5,
									 0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： VCOM过流，设备关电!"
		{E_PWR_CHECK_ERR_VCOM_UC, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x43 ,0x4f ,0x4d ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5,
									 0x81 ,0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： VCOM欠流，设备关电!"
		{E_PWR_CHECK_ERR_VBL_OV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x42 ,0x4c ,0xe8 ,0xbf ,0x87 ,0xe5 ,0x8e ,0x8b,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VBL过压，设备关电!"
		{E_PWR_CHECK_ERR_VBL_UV,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x42 ,0x4c ,0xe6 ,0xac ,0xa0 ,0xe5 ,0x8e ,0x8b,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VBL欠压，设备关电!"
		{E_PWR_CHECK_ERR_VBL_OC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x42 ,0x4c ,0xe8 ,0xbf ,0x87 ,0xe6 ,0xb5 ,0x81,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VBL过流，设备关电!"
		{E_PWR_CHECK_ERR_VBL_UC,  {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x42 ,0x4c ,0xe6 ,0xac ,0xa0 ,0xe6 ,0xb5 ,0x81,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VBL欠流，设备关电!"
		{E_PWR_CHECK_ERR_VBL_OPEN,{0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0x56,
									 0x42 ,0x4c ,0xe5 ,0xbc ,0x80 ,0xe8 ,0xb7 ,0xaf,
									 0xef ,0xbc ,0x8c ,0xe8 ,0xae ,0xbe ,0xe5 ,0xa4,
									 0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5 ,0x21,0x00}}, //"电源错误： VBL开路，设备关电!"
		{E_PWR_CHECK_ERR_VBL_SHORT_LIGHT, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0xe8,
									 0x83 ,0x8c ,0xe5 ,0x85 ,0x89 ,0xe7 ,0x81 ,0xaf,
									 0xe7 ,0x8f ,0xa0 ,0xe7 ,0x9f ,0xad ,0xe8 ,0xb7,
									 0xaf ,0xe3 ,0x80 ,0x82 ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： 背光灯珠短路。设备关电!"
		{E_PWR_CHECK_ERR_VBL_SHORT_PN, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0xe8,
									 0x83 ,0x8c ,0xe5 ,0x85 ,0x89 ,0xe6 ,0xad ,0xa3,
									 0xe8 ,0xb4 ,0x9f ,0xe7 ,0x9f ,0xad ,0xe8 ,0xb7,
									 0xaf ,0xe3 ,0x80 ,0x82 ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： 背光正负短路。设备关电!"
		{E_PWR_CHECK_ERR_VBL_SHORT_NN, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0xe8,
									 0x83 ,0x8c ,0xe5 ,0x85 ,0x89 ,0xe8 ,0xb4 ,0x9f,
									 0xe8 ,0xb4 ,0x9f ,0xe7 ,0x9f ,0xad ,0xe8 ,0xb7,
									 0xaf ,0xe3 ,0x80 ,0x82 ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： 背光负负短路。设备关电!"
		{E_PWR_CHECK_ERR_VBL_SHORT_N_GND, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0xe8,
									 0x83 ,0x8c ,0xe5 ,0x85 ,0x89 ,0xe8 ,0xb4 ,0x9f,
									 0xe5 ,0x9c ,0xb0 ,0xe7 ,0x9f ,0xad ,0xe8 ,0xb7,
									 0xaf ,0xe3 ,0x80 ,0x82 ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： 背光负地短路。设备关电!"
		{E_PWR_CHECK_ERR_VBL_SHORT_P_GND, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0xe8,
									 0x83 ,0x8c ,0xe5 ,0x85 ,0x89 ,0xe6 ,0xad ,0xa3,
									 0xe5 ,0x9c ,0xb0 ,0xe7 ,0x9f ,0xad ,0xe8 ,0xb7,
									 0xaf ,0xe3 ,0x80 ,0x82 ,0xe8 ,0xae ,0xbe ,0xe5,
									 0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7 ,0x94 ,0xb5,
									 0x21 ,0x00}}, //"电源错误： 背光正地短路。设备关电!"
		{E_PWR_CHECK_OTHER, {0xe7 ,0x94 ,0xb5 ,0xe6 ,0xba ,0x90 ,0xe9 ,0x94,
									 0x99 ,0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x9a ,0xe5,
									 0x85 ,0xb6 ,0xe4 ,0xbb ,0x96 ,0xe9 ,0x94 ,0x99,
									 0xe8 ,0xaf ,0xaf ,0xef ,0xbc ,0x8c ,0xe8 ,0xae,
									 0xbe ,0xe5 ,0xa4 ,0x87 ,0xe5 ,0x85 ,0xb3 ,0xe7,
									 0x94 ,0xb5 ,0x21 ,0x00}}, //"电源错误： 其他错误，设备关电!"
};

static const char* getErrorStr(int error)
{
	int errorSize = sizeof(sgPwrErrorInfo)/sizeof(pwrErrorInfo_t);
	const char* pErrorStr = sgPwrErrorInfo[errorSize - 1].error;
	int i = 0;
	for (i = 0; i < errorSize; i++)
	{
		pwrErrorInfo_t* pInfo = &sgPwrErrorInfo[i];
		if (pInfo->id == error)
		{
			pErrorStr = pInfo->error;
			break;
		}
	}

	return pErrorStr;
}

static void pwrErrorProcess(int error)
{
	const char* pError = getErrorStr(error);
	// notify PC
	client_notify_msg(NOTIFY_ERROR_POWER_CHECK, pError);

	// notify box.
	char errorResult[64] = "";
	box_gen_pass_failed_msg_data("Fail", 0, errorResult, sizeof(errorResult));
	boxFeedback(pError, errorResult);
}

static void checkPwr(PWR_CHANNEL_E channel)
{
	if (!pSgPwrTaskInfo)
		return;

	sByPtnPwrInfo* pActualPwr = NULL;
	main_power_info_t* pPwrInfo = NULL;
	if (channel == PWR_CHANNEL_LEFT)
		pPwrInfo = &pSgPwrTaskInfo->pwrInfo[0];
	else
		pPwrInfo = &pSgPwrTaskInfo->pwrInfo[1];

	pActualPwr = &pPwrInfo->main_power;

	power_cfg_info_t* pFixPwr =  get_current_power_cfg();

	int ret = 0;

	do
	{
		ret = checkPowerEquitable(&pFixPwr->power_module, pActualPwr);
		if (ret)
			break;

		if (pActualPwr->vbl_reserved[0] != 1)
			break;

		ret = power_check_vbl(&pFixPwr->power_module, pActualPwr);
		if (ret)
			break;
	}while (0);

	if (ret != E_PWR_CHECK_OK)
	{
		printPowerInfo(pActualPwr);
	    client_pg_shutON(0, 0, 0, 0);
		pwrErrorProcess(ret);
	}

	if (pFixPwr->power_module.VSP == 0)
	{
		pActualPwr->VSP = 0;
		pActualPwr->iVSP = 0;
	}

	if (pFixPwr->power_module.VSN == 0)
	{
		pActualPwr->VSN = 0;
		pActualPwr->iVSN = 0;
	}

	if (pFixPwr->power_module.ELVDD == 0)
	{
		pActualPwr->ELVDD = 0;
		pActualPwr->iELVDD = 0;
	}

	if (pFixPwr->power_module.ELVSS == 0)
	{
		pActualPwr->ELVSS = 0;
		pActualPwr->iELVSS = 0;
	}

	if (channel == PWR_CHANNEL_LEFT)
		boxSavePwrData(pActualPwr, pPwrInfo->vcom, pPwrInfo->ivcom);	//控制盒刷新电源信息
}

static void initPwrMsgHead(pwrMsgHead_t* pMsg, int cmd, int type, int len,
		int dAddr, int signalType, int signalFd, int ipaddr, PWR_CHANNEL_E channel,
		int result)
{
	pMsg->cmd = cmd;
	pMsg->type = type;
	pMsg->len = len;
	pMsg->destAddr = dAddr;
	pMsg->signalType = signalType;
	pMsg->signalFd = signalFd;
	pMsg->ipaddr = ipaddr;
	pMsg->ways = channel;
	pMsg->result = result;
}

void powerCmdCalibrationPowerItem(PWR_CHANNEL_E channel, int powerType, int action, int powerData)
{
	char temp[128] = "";
	pwrMsgHead_t* pMsg = (pwrMsgHead_t *)temp;

	initPwrMsgHead(pMsg, PWR_CMD_POWER_CALIBRATION, MSG_TYPE_POWER, PWR_MSG_HEAD_LEN - 4 + sizeof(calibrationPowerItem_t),
			0, PWR_MSG_FROM_LOCAL, 0, 0, channel, 0);

	calibrationPowerItem_t* pItem = (calibrationPowerItem_t *)&pMsg->payload;
	pItem->powerType = powerType;
	pItem->action = action;
	if (powerData >= 0)
	{
		pItem->direction = 1;
		pItem->delta = powerData;
	}
	else
	{
		pItem->direction = 2;
		pItem->delta = abs(powerData);
	}

	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);
	pwrSnd2Serial(pMsg, PWR_MSG_HEAD_LEN + sizeof(calibrationPowerItem_t));
	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);
}

void pwrSetVol(unsigned char isOn, unsigned char type, short volta)
{
	char temp[128] = "";
	pwrMsgHead_t* pMsg = (pwrMsgHead_t *)temp;

	initPwrMsgHead(pMsg, PWR_CMD_SET_VOL, MSG_TYPE_POWER, PWR_MSG_HEAD_LEN - 4 + sizeof(singlePwrInfo_t),
			0, PWR_MSG_FROM_LOCAL, 0, 0, PWR_CHANNEL_ALL, 0);

	singlePwrInfo_t* pInfo = &pMsg->payload;
	pInfo->isOn = isOn;
	pInfo->type = type;
	pInfo->volta = volta;

	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);
	pwrSnd2Serial(pMsg, PWR_MSG_HEAD_LEN + sizeof(singlePwrInfo_t));
	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);
}

void pwrUpgrade(unsigned char* pData, int length)
{
	if (NULL == pData || length <= 0)
		return;

	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);

	unsigned char reqHead[8] = "";
	reqHead[0] = 0x72; //72开始升级   73数据包
	reqHead[1] = MSG_TYPE_POWER; //05电源， 0B控制盒
	reqHead[2] = 0x4;  //长度(低位在前，高位在后)
	pwrSnd2Serial(reqHead, sizeof(reqHead));

	usleep(1000*1000);

	//数据报文
	unsigned int offset = 0;
	unsigned char* pBuf = pData;
	unsigned int len = length;

	while(len > 0)
	{
		unsigned int dataLen = (len >= 1024) ? 1024 : len;
		unsigned char dataPkt[1024 + PWR_UPGRADE_INFO_HEAD_LEN] = "";
		pwrUpgradeInfo_t* pInfo = (pwrUpgradeInfo_t*)dataPkt;
		pInfo->dataType = 0x73;
		pInfo->devType = MSG_TYPE_POWER;
		pInfo->len = sizeof(pwrUpgradeInfo_t) - 8 + dataLen;
		pInfo->offset = offset;
		pInfo->blockSize = dataLen;
		pInfo->totalSize = length;
		memcpy(&pInfo->payLoad, pBuf, dataLen);

		pwrSnd2Serial(dataPkt, PWR_UPGRADE_INFO_HEAD_LEN + dataLen);

		offset += dataLen;
		pBuf += dataLen;
		len -= dataLen;
	}

	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);
}

void pwrSetState(bool bOn, PWR_CHANNEL_E channel)
{
	char temp[128] = "";
	pwrMsgHead_t* pMsg = (pwrMsgHead_t *)temp;

	int cmd = 0;
	if (bOn)
		cmd = PWR_CMD_POWER_ON;
	else
		cmd = PWR_CMD_POWER_OFF;

	initPwrMsgHead(pMsg, cmd, MSG_TYPE_POWER, PWR_MSG_HEAD_LEN - 4,
			0, 0x03, 0, 0, channel, 0);

	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);
	pwrSnd2Serial(pMsg, PWR_MSG_HEAD_LEN);
	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);

	if (bOn)
		setPwrCheckPause(false);
	else
		setPwrCheckPause(true);
}

//set power user setting
void pwrSetCfg(s1103PwrCfgDb* pCfg)
{
	char temp[1024] = "";
	pwrMsgHead_t* pMsg = (pwrMsgHead_t *)temp;
	int payloadLen = sizeof(s1103PwrCfgDb);

	initPwrMsgHead(pMsg, PWR_CMD_CFG_POWER_STRUCT, MSG_TYPE_POWER, PWR_MSG_HEAD_LEN - 4 + payloadLen,
			0xffff, 0, 0, 0, 0xff, 0);

    memcpy(&pMsg->payload, pCfg, payloadLen);
	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);
	pwrSnd2Serial(pMsg, PWR_MSG_HEAD_LEN + payloadLen);
	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);
}

void pwrContorl(bool bOn, PWR_CHANNEL_E channel)
{
	char temp[80] = "";
	pwrMsgHead_t* pMsg = (pwrMsgHead_t *)temp;
	int payloadLen = 6;

	initPwrMsgHead(pMsg, PWR_CMD_CTRL_SWITCH, MSG_TYPE_POWER, PWR_MSG_HEAD_LEN - 4 + payloadLen,
			0, 0x03, 0, 0, channel, 0);

	*(int *)&pMsg->payload = 6;	// VSP
	*((int *)&pMsg->payload + 1) = bOn;

	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);
	pwrSnd2Serial(pMsg, PWR_MSG_HEAD_LEN + payloadLen);
	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);
}

static void getPwrSoftwareVersion()
{
	pwrMsgHead_t msg;
	initPwrMsgHead(&msg, PWR_CMD_GET_POWER_VER, MSG_TYPE_POWER, PWR_MSG_HEAD_LEN - 4,
			0, 0x03, 0, 0, PWR_CHANNEL_ALL, 0);

	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);
	pwrSnd2Serial(&msg, sizeof(msg));
	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);
}

void getPwrInfo(PWR_CHANNEL_E channel)
{
	if (channel == PWR_CHANNEL_ALL)
		return;

	pwrMsgHead_t msg;
	initPwrMsgHead(&msg, PWR_CMD_GET_VOL, MSG_TYPE_POWER, PWR_MSG_HEAD_LEN - 4,
			0, 0, 0, 0, channel, 0);

	pthread_mutex_lock(&pSgPwrTaskInfo->mutex);
	pwrSnd2Serial(&msg, PWR_MSG_HEAD_LEN);
	pthread_mutex_unlock(&pSgPwrTaskInfo->mutex);
}

static void setPwrCheckPause(bool bPause)
{
	pSgPwrTaskInfo->bPwrUpdatePaused = bPause;
}

void setNtcCheckPause(bool bPause)
{
	pSgPwrTaskInfo->bNtcCheckPaused = bPause;
}

static void* pwrInfoGetTask(void* pArg)
{
	pwrTaskInfo_t* pInfo = (pwrTaskInfo_t*)pArg;
	while (pInfo->bPwrUpdateStarted)
	{
		if (pInfo->bPwrUpdatePaused)
			continue;

		_msleep(1500);
		getPwrInfo(PWR_CHANNEL_LEFT);
		_msleep(100);
		getPwrInfo(PWR_CHANNEL_RIGHT);
	}

	return NULL;
}

static void* ntcMonitorTask(void* pArg)
{
	pwrTaskInfo_t* pInfo = (pwrTaskInfo_t*)pArg;
	monitor_cfg_info_t *pFixCfg = get_current_monitor_cfg();

	while (pInfo->bNtcCheckStarted)
	{
		_msleep(500);

		if (pInfo->bNtcCheckPaused)
			continue;

		int ntcAgValue = mcu_read_ntc_ag_data(TTL_LVDS_CHANNEL_LEFT);
		if (ntcAgValue > 200*1000 || ntcAgValue <= 0)
			continue;

		if ( (ntcAgValue < pFixCfg->ntc_min_check_val)
			|| (ntcAgValue > pFixCfg->ntc_max_check_val) )
		{
			printf("NTC Warnning: ntc: %d, min: %d, max: %d.\n", ntcAgValue,
					pFixCfg->ntc_min_check_val, pFixCfg->ntc_max_check_val);

			char msg[256] = "";
			sprintf(msg, "NG: NTC检测出错。当前值为%d欧, 设置范围为：%d欧 - %d欧.",
					ntcAgValue, pFixCfg->ntc_min_check_val, pFixCfg->ntc_max_check_val);

		    client_pg_shutON(0, 0, 0, 0);
			client_notify_msg(NOTIFY_ERROR_NTC_CHECK, msg);
			box_notify_NTC_error_down();
		}
	}
}

static void processRcvFromSerial(void* pData, unsigned int length)
{
	if (NULL == pData || length < PWR_MSG_HEAD_LEN)
		return;

	pwrMsgHead_t* pMsg = (pwrMsgHead_t *)pData;
    if (pMsg->type == 0x85 && pMsg->cmd == PWR_CMD_GET_VOL)
    {
		sByPtnPwrInfo *pPwrInfo = (sByPtnPwrInfo*)&pMsg->payload;
		int channel = 0;
		if (pMsg->ways == PWR_CHANNEL_LEFT)
			channel = 1;
		else
			channel = 2;

        client_sendPower(channel, pPwrInfo); //通知PG上位机, 显示电源信息

        int ivcom = mcu_read_ivcom();

		if (pMsg->ways == PWR_CHANNEL_LEFT)
		{
			pSgPwrTaskInfo->pwrInfo[0].main_power = *pPwrInfo;
			pSgPwrTaskInfo->pwrInfo[0].vcom = mcu_read_vcom_volt(TTL_LVDS_CHANNEL_LEFT);
			pSgPwrTaskInfo->pwrInfo[0].ivcom = ivcom;
		}
		else
		{
			pSgPwrTaskInfo->pwrInfo[1].main_power = *pPwrInfo;
			pSgPwrTaskInfo->pwrInfo[1].vcom = mcu_read_vcom_volt(TTL_LVDS_CHANNEL_RIGHT);;
			pSgPwrTaskInfo->pwrInfo[1].ivcom = ivcom;
		}

		checkPwr(pMsg->ways);
    }
	else if(pMsg->cmd == PWR_CMD_GET_POWER_VER)
	{
		unsigned char* ver = (char *)&pMsg->payload;
		//通知PG上位机, 电源程序版本
		unsigned int pwrVersion = ver[0] << 16  | ver[1] << 8 | ver[2];
		client_sendPowerVersion(1, pwrVersion);
	}
}

void pwrTaskInit(void)
{
	pSgPwrTaskInfo = (pwrTaskInfo_t *)calloc(1, sizeof(pwrTaskInfo_t));
	pwrSerialInit(processRcvFromSerial);

	pthread_mutex_init(&pSgPwrTaskInfo->mutex, NULL);

	pSgPwrTaskInfo->bPwrUpdateStarted = true;
	pSgPwrTaskInfo->bPwrUpdatePaused = true;
	pthread_create(&pSgPwrTaskInfo->pwrUpdateTaskId, NULL, pwrInfoGetTask, pSgPwrTaskInfo);

	pSgPwrTaskInfo->bNtcCheckPaused = true;
	pSgPwrTaskInfo->bNtcCheckStarted = true;
	pthread_create(&pSgPwrTaskInfo->ntcCheckTaskId, NULL, ntcMonitorTask, pSgPwrTaskInfo);
    return;
}

void pwrTaskDeinit(void)
{
	pwrSerialDeinit();
	pSgPwrTaskInfo->bPwrUpdateStarted = false;
	pSgPwrTaskInfo->bPwrUpdatePaused = true;
	pthread_join(pSgPwrTaskInfo->pwrUpdateTaskId, NULL);

	pSgPwrTaskInfo->bNtcCheckPaused = false;
	pSgPwrTaskInfo->bNtcCheckStarted = true;
	pthread_join(pSgPwrTaskInfo->ntcCheckTaskId, NULL);

	free(pSgPwrTaskInfo);
}
